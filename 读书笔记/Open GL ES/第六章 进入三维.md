# 第六章 进入三维

- 二维可以视为三维使用的技巧就是使用一个线性投影，原理就是一个消失点在一个点上，

- 从着色器到屏幕坐标的变换

  要让一个顶点都显示在屏幕上，它的xyz分量要在-1,1的范围内

- 裁剪空间：任意给定位置，它的x,y,z都在一个范围之内的，-w到w

- 透视法：一个顶点成为一个OPENGLES实际的坐标之前执行一个步骤，他叫做透视法。透视之后，那个点就在坐标中了，之后所有的东西都在-1，1之间了。

  三维空间的实现：OpenGLES会吧每一个gl_position的x,y,z分量都除以w，w来表示距离的时候，使得远处的变到了与中心更近的地方。w越大，举例中心的位置就越小，

- 视口的变换

  在我们最后的结果之前，OPenGLES会将坐标x,y映射到一个区域中，这个区域是操作留出来的一个位置，被称为视口。我们将坐标告诉了OpenGLES之后，将（-1，-1，-1）(1,1,1)之外的数据裁剪掉。

  ## 案例

  1，首先更新坐标，加入新的坐标z和w。

  2.一般的操作步骤：

  - 更新坐标

    ```
    		float []tableVertices = {
    				/*
    				 * 
    				 * 00被公用，最后的-0.5变为一周，被重合
    				 * 为了可以表示颜色，这个时候在点坐标的最后加上颜色
    				 * */
    	               0f,    0f,    0f,   1.5f, 1f,   1f,   1f,         
    	               -0.5f, -0.8f, 0f,   1f,	0.7f, 0.7f, 0.7f,            
    	                0.5f, -0.8f, 0f,   1f,	0.7f, 0.7f, 0.7f,
    	                0.5f,  0.8f, 0f,   2f,	0.7f, 0.7f, 0.7f,
    	               -0.5f,  0.8f, 0f,   2f,  0.7f, 0.7f, 0.7f,
    	               -0.5f, -0.8f, 0f,   1f,	0.7f, 0.7f, 0.7f,
    
    	               // Line 1
    	               -0.5f, 0f, 0f, 1.5f,  1f, 0f, 0f,
    	                0.5f, 0f, 0f, 1.5f ,  1f, 0f, 0f,
    
    	               // Mallets
    	               0f, -0.25f, 0f, 1.25f,  0f, 0f, 1f,
    	               0f,  0.25f, 0f, 1.25f,  1f, 0f, 0f
    		};
    ```

  - 更新点数

    ```
    	//更新，从2个点变为4个点
    	private static final int POSITION_COMPONENT_COUNT = 4;
    ```

    加入了一个z,w，更新了所有的顶单，w值表现了显示出来的宽度。z坐标的作用是得到一个立体感，所以我们可以不使用z坐标，先将其设置为0.

    w变量，我们可以根据在执行过程中，远近 ，提供不同的值，比值大下代表距离的远近。

    ## 使用透视投影

    ​	前面通过正交来弥补宽高之比，现在可以通过包围整个立方体，它代表这个OpenGL最终在视口上的渲染内容，也就可以得到最终的内容。

    ​	使用透视矩阵

    - 创建自己的perspectiveM

      ```
      
      ```

    - 

    ## 视椎体

    #