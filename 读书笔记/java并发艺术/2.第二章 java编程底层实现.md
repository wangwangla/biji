# 底层实现
```
    java语言编译之后生成字节码文件，字节码文件被虚拟机获取转换为汇编语言被机器执行。底层实现依赖于jvm的实现和cpu指令。
```
## volatile实现
```
    多线程的两个关键字volatile和synchronized，volatile比synchronized轻量级，可以实现共享变量的可见性，其他线程可以立刻感知到数据的变化，不会引起上下文的切换。

```
### volatile实现原理
```
    当执行的时候会对volatile进行写操作为例
    volatile修饰的会出现lock修饰的代码

    lock会有什么作用：
        将当前的处理器缓存行的数据写回到系统内容
        其他cpu里的数据无效。
        如果设置了lock，设置lock之后，就会将它写入到系统内存，但是系统内存中其他工作内存仍然是就的，这个时候就会通过每个处理器嗅探总线上的数据来检查自己是否已经过期，过期将会标记，当使用的是就会重新的获取这个值。
    
    内存模型
        工作内存 系统内存 
        操作的时候将系统内存的数据放入到工作内存，在工作内存进行操作，并不会写入到系统内存，这也是会发生数据不一致的原因

    volatile的原则
        lock前缀会引起处理器缓存写到内存中
        一个处理器缓存中的数据无效


```
### synchronized的实现原理
```
    它可以使用的地方
    使用普通同步方法
    静态同步方法
    同步方法

    在执行的时候，如果出现异常，那么就会将锁释放。
    在JVM里的实现是通过监听来完成的，Moniter进入和退出来实现同步和代码块，如果是代码块那么就是moniterenter好人monitorexit实现的，但是同步方法并没有说明

    monitorenter和monitorexit编译后会插入到代码开始和结束的地方或者异常出
    每一个对象都有一个monitor，当monitor被持有后就会处于锁定状态，执行到monitorenter就会尝试去获取monitor的执行权。
    
