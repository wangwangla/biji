# 原理篇

### 线程IO模型

​	Redis是一个单线程的程序，nginx、nodejs都是单线程的。但是他也很快，这是因为数据都在内存中，计算是内存级别的。在处理O(n)的指令就会出现卡顿的问题。

​	Redis为什么可以处理多个客户端，这是因为它采用多路复用。

### 非阻塞IO

​	默认读写是阻塞的，最后可以是一个n，这个参数由套接字传递的，如果没有数据就不糊会返回，卡在哪里。直到有数据或者是断开连接，才会返回或者是继续处理。读的时候，只有放写满了才会阻塞。当有非堵塞的时候，就会出现一个问题，怎样就写完了，怎样就读完了，如果读不完怎么办。这个通过轮询来进行处理这个问题。

### 多路复用

最简单的时间轮询API Select函数，提供给用户的API.输入是read_fds和write_fds.输出是对应的可读事件，提供一个timeout.没有任何事件的时候，等timeout就会进入堵塞，有事件来就会返回。拿到事件就会进行轮询，进入一个死循环。

### 指令队列

Redis会将每一个客户端套接字都关联一个指令队列，通过队列来执行任务，先到先服务。

### 服务队列

同时提供一个响应队列，Redis通过队列将返回结果返回给客户端，为null，就不去获取写事件了。将客户端描述符拿出来。当队列有数据了在进行获取。

###  定时任务

单线程的任务，如果在一个IO上堵塞，那么定时任务到时怎么办？
Redis的计时放在一个堆中，将快要执行的任务放在最上面，每一个循环周期中，Redis都会对最小堆里面已经到时的进行处理，将快要执行的任务时间记下来，这个值是select的timeout。在这个时间可以安心睡了。



## 持久化

​	Redis数据存储在内存中，宕机就会消失，那么就可以使用一种策略，让其可以一种存在，第一种使用快照；第二种使用AOF日志。但是有个问题，AOF的增大，启动会变慢。快照是存在一个紧凑的二进制文件中。

### 快照原理

​	Redis是单线程，他需要执行多个客户端的操作。如果需要快照，那么就需要一边服务一边进行IO快照。并且IO操作不可以多路复用。

​	问题：快照的同时，数据还在改变，这怎么办。

​	Redis使用的是WOW(copy on write)

### fork

​	持久化会调用glibc函数fork产生一个子进程，快照持久化完全交给子进程来处理，父进程继续响应客户端。

在子进程进行数据持久化的时候，不会修改现有数据的内存数据结构，仅仅只是循环，将数据持久化到内存中。父进程对客户端进行处理，不断修改。

​	Copy on write在复制上写，将数据段复制一个，然后在上面进行修改。



### AOF原理

AOF存储的是Redis服务器执行的指令，仅仅记录了修改的指令。

AOF的流程为：收到指令，先对指令进行效验、逻辑处理，没有问题，就会立即将文本指令存储到AOF日志中**先执行，在写入日志**

AOF日志过大之后，需要对其进行瘦身处理。

### AOF日志重写

Redis提供了bgrewriteaof指令进行瘦身，原理是：开辟一个新的子进程对内存进行遍历，转化为一系列的指令，将指令放入到新的一个日志中，再将执行期间的日志追加，然后将旧的日志替换掉。瘦身就算结束了。

### fsyns

aof日志的形式放在内存中，但是aof读写的时候，先将数据放入内存中，然后在刷到磁盘。

