# 线程安全
```
```
## 线程安全
```

    当访问一个类或者对象，没一次访问都可以正确的表现出行为，那么就是线程安全的。

    synchronized:可以在任意对象及方法上进行加锁，加锁的这段代码成为“互斥区”或者“临界区”

```
## 举例
```
    public class ThreadDemo01 extends Thread{
        int count = 5;
        public void run(){
            count--;
            System.out.println(count);
        }
        public static void main(String[] args) {
            ThreadDemo01 threadDemo01 = new ThreadDemo01();
            Thread thread01 = new Thread(threadDemo01,"t1");
            Thread thread02 = new Thread(threadDemo01,"t1");
            Thread thread03 = new Thread(threadDemo01,"t1");
            Thread thread04 = new Thread(threadDemo01,"t1");
            thread01.start();
            thread02.start();
            thread03.start();
            thread04.start();
        }

    }
    =========结果===========
    3
    3
    2
    1
    public synchronized void run(){}
    =========结果===========
    4
    3
    2
    1
首先一个线程进入执行，其他的线程在外面等待，不断的判断什么时候可以获取到这个锁。这个时候就会发生竞争的问题。

```
## 对象锁和类锁
```

    一个对象一个锁
    package kw.test.thread;
    public class ThreadDemo02 extends Thread{
        int num =  0;
        private void show(String name) {
            System.out.println(num+"-------------------"+name);
            System.out.println(num+"------==============---"+name);
        }
        public static void main(String[] args) {
            final ThreadDemo02 threadDemo02 = new ThreadDemo02();
            Thread thread1 = new Thread(new Runnable() {
                @Override
                public void run() {
                    // TODO Auto-generated method stub
                    threadDemo02.show("kang");
                }
            });
            Thread thread2 = new Thread(new Runnable() { 
                @Override
                public void run() {
                    // TODO Auto-generated method stub
                    threadDemo02.show("wang");
                }
            });
            thread1.start();
            thread2.start();
        }
    }

    一个对象一个锁，所以上述代码是没有任何影响的，他们各自执行，即使加上synchronized也是不可以的，因为锁的级别不一样
    假如改为一个类锁，那么加上synchronized和不加有非常大的差异。

